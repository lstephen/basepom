<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RotationSelection.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ootp-ai</a> &gt; <a href="index.source.html" class="el_package">com.github.lstephen.ootp.ai.selection.rotation</a> &gt; <span class="el_source">RotationSelection.java</span></div><h1>RotationSelection.java</h1><pre class="source lang-java linenums">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) 
// Source File Name:   RotationSelection.java
package com.github.lstephen.ootp.ai.selection.rotation;

import com.github.lstephen.ootp.ai.io.Printables;
import com.github.lstephen.ootp.ai.player.Player;
import com.github.lstephen.ootp.ai.player.Slot;
import com.github.lstephen.ootp.ai.selection.Mode;
import com.github.lstephen.ootp.ai.selection.Selection;
import com.github.lstephen.ootp.ai.selection.rotation.Rotation.Role;
import com.github.lstephen.ootp.ai.stats.PitcherOverall;
import com.github.lstephen.ootp.ai.stats.PitchingStats;
import com.github.lstephen.ootp.ai.stats.TeamStats;

import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.function.Supplier;
import java.util.stream.Stream;

import com.github.lstephen.ai.search.HillClimbing;
import com.github.lstephen.ai.search.RepeatedHillClimbing;
import com.github.lstephen.ai.search.Validator;
import com.github.lstephen.ai.search.action.Action;
import com.github.lstephen.ai.search.action.ActionGenerator;

import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.google.common.collect.*;

public final class RotationSelection implements Selection {

    private final TeamStats&lt;PitchingStats&gt; predictions;

    private final PitcherOverall method;

    private final RotationDefinition definition;

    private final Multiset&lt;Slot&gt; slots;

    private RotationSelection(
        TeamStats&lt;PitchingStats&gt; predictions,
        PitcherOverall method,
        RotationDefinition definition,
<span class="nc" id="L47">        Multiset&lt;Slot&gt; slots) {</span>

<span class="nc" id="L49">        this.predictions = predictions;</span>
<span class="nc" id="L50">        this.method = method;</span>
<span class="nc" id="L51">        this.definition = definition;</span>
<span class="nc" id="L52">        this.slots = slots;</span>
<span class="nc" id="L53">    }</span>

    public ImmutableMultimap&lt;Slot, Player&gt; select(
        Iterable&lt;Player&gt; forced, Iterable&lt;Player&gt; available) {

<span class="nc" id="L58">        Rotation r = selectRotation(forced, available);</span>

<span class="nc" id="L60">        Multimap&lt;Slot, Player&gt; assigned = HashMultimap.create();</span>

<span class="nc bnc" id="L62" title="All 2 branches missed.">        for (Player p : r.getStarters()) {</span>
<span class="nc" id="L63">            assigned.put(Slot.SP, p);</span>
<span class="nc" id="L64">        }</span>

<span class="nc bnc" id="L66" title="All 2 branches missed.">        for (Player p : r.getNonStarters()) {</span>
<span class="nc" id="L67">            assigned.put(Slot.MR, p);</span>
<span class="nc" id="L68">        }</span>

<span class="nc" id="L70">        return ImmutableMultimap.copyOf(assigned);</span>
    }

    public Rotation selectRotation(Iterable&lt;Player&gt; forced, Iterable&lt;Player&gt; available) {

<span class="nc" id="L75">        System.out.println(&quot;Selecting rotation...&quot;);</span>
<span class="nc" id="L76">        System.out.println(&quot;Forced:&quot; + Iterables.size(forced));</span>
<span class="nc" id="L77">        System.out.println(&quot;Available:&quot; + Iterables.size(available));</span>

        HillClimbing&lt;Rotation&gt; hc = HillClimbing
<span class="nc" id="L80">            .&lt;Rotation&gt;builder()</span>
<span class="nc bnc" id="L81" title="All 4 branches missed.">            .validator(r -&gt; r.isValid() &amp;&amp; r.get(Role.SP).size() == definition.getRotationSize())</span>
<span class="nc" id="L82">            .heuristic(heuristic())</span>
<span class="nc" id="L83">            .actionGenerator(actionGenerator(forced, available))</span>
<span class="nc" id="L84">            .build();</span>

<span class="nc" id="L86">        Rotation r = new RepeatedHillClimbing&lt;Rotation&gt;(</span>
<span class="nc" id="L87">              initialStateGenerator(forced, available), hc)</span>
<span class="nc" id="L88">            .search();</span>

<span class="nc bnc" id="L90" title="All 2 branches missed.">        for (Player p : Player.byShortName().sortedCopy(r.getAll())) {</span>
<span class="nc" id="L91">            System.out.print(p.getShortName() + &quot;/&quot;);</span>
<span class="nc" id="L92">        }</span>
<span class="nc" id="L93">        System.out.println();</span>
<span class="nc" id="L94">        return r;</span>
    }

    private Ordering&lt;Rotation&gt; heuristic() {
      Ordering&lt;Rotation&gt; byOverall = Ordering
<span class="nc" id="L99">        .natural()</span>
<span class="nc" id="L100">        .onResultOf(new Function&lt;Rotation, Double&gt;() {</span>
          public Double apply(Rotation r) {
<span class="nc" id="L102">            Double score = 0.0;</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">            for (Player p : r.getAll()) {</span>
<span class="nc" id="L104">              score += method.getPlus(predictions.getOverall(p));</span>
<span class="nc" id="L105">            }</span>
<span class="nc" id="L106">            return score;</span>
          }});

      return Ordering
<span class="nc" id="L110">        .natural()</span>
<span class="nc" id="L111">        .onResultOf(new Function&lt;Rotation, Double&gt;() {</span>
            public Double apply(Rotation r) {
<span class="nc" id="L113">                return r.score(predictions, method);</span>
            }
        })
<span class="nc" id="L116">        .compound(byOverall);</span>
    }


    private Supplier&lt;Rotation&gt; initialStateGenerator(final Iterable&lt;Player&gt; forced, final Iterable&lt;Player&gt; available) {
<span class="nc" id="L121">        return new Supplier&lt;Rotation&gt;() {</span>
            @Override
            public Rotation get() {
<span class="nc" id="L124">                List&lt;Player&gt; ps = Lists.newArrayList(available);</span>
<span class="nc" id="L125">                Iterables.removeAll(ps, ImmutableSet.copyOf(forced));</span>

<span class="nc" id="L127">                Collections.shuffle(ps);</span>

<span class="nc" id="L129">                List&lt;Player&gt; sps = Lists.newArrayList();</span>
<span class="nc" id="L130">                List&lt;Player&gt; mrs = Lists.newArrayList();</span>
<span class="nc" id="L131">                List&lt;Player&gt; rest = Lists.newArrayList();</span>

<span class="nc bnc" id="L133" title="All 2 branches missed.">                for (Player p : forced) {</span>
<span class="nc bnc" id="L134" title="All 4 branches missed.">                    if (p.getSlots().contains(Slot.SP) &amp;&amp; sps.size() &lt; definition.getRotationSize()) {</span>
<span class="nc" id="L135">                        sps.add(p);</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">                    } else if (mrs.size() &lt; definition.getRelieversSize()) {</span>
<span class="nc" id="L137">                        mrs.add(p);</span>
                    } else {
<span class="nc" id="L139">                        rest.add(p);</span>
                    }
<span class="nc" id="L141">                }</span>

<span class="nc bnc" id="L143" title="All 2 branches missed.">                for (Player p : ps) {</span>
<span class="nc bnc" id="L144" title="All 4 branches missed.">                    if (p.getSlots().contains(Slot.SP) &amp;&amp; sps.size() &lt; definition.getRotationSize()) {</span>
<span class="nc" id="L145">                        sps.add(p);</span>
                    }
<span class="nc" id="L147">                }</span>

<span class="nc" id="L149">                ps.removeAll(sps);</span>

<span class="nc" id="L151">                sps.addAll(FluentIterable</span>
<span class="nc" id="L152">                    .from(ps)</span>
<span class="nc" id="L153">                    .limit(definition.getRotationSize() - sps.size())</span>
<span class="nc" id="L154">                    .toList());</span>

<span class="nc" id="L156">                ps.removeAll(sps);</span>

<span class="nc" id="L158">                mrs.addAll(FluentIterable</span>
<span class="nc" id="L159">                    .from(ps)</span>
<span class="nc" id="L160">                    .limit(definition.getRelieversSize() - mrs.size())</span>
<span class="nc" id="L161">                    .toList());</span>

<span class="nc" id="L163">                ps.removeAll(mrs);</span>

<span class="nc" id="L165">                rest.addAll(FluentIterable</span>
<span class="nc" id="L166">                    .from(ps)</span>
<span class="nc" id="L167">                    .limit(Math.max(0, slots.size() - sps.size() - mrs.size() - rest.size()))</span>
<span class="nc" id="L168">                    .toList());</span>

<span class="nc" id="L170">                Rotation initial = Rotation.create(sps, mrs, rest);</span>

<span class="nc bnc" id="L172" title="All 2 branches missed.">                if (!initial.isValid()) {</span>
<span class="nc" id="L173">                    Printables.print(initial).to(System.out);</span>
                }

<span class="nc" id="L176">                Preconditions.checkState(initial.isValid());</span>

<span class="nc" id="L178">                return initial;</span>
            }
        };
    }

    private ActionGenerator&lt;Rotation&gt; actionGenerator(final Iterable&lt;Player&gt; forced, final Iterable&lt;Player&gt; available) {
<span class="nc" id="L184">        return new ActionGenerator&lt;Rotation&gt;() {</span>
            @Override
            public Stream&lt;Action&lt;Rotation&gt;&gt; apply(Rotation r) {
<span class="nc" id="L187">                Iterable&lt;Action&lt;Rotation&gt;&gt; actions =</span>
<span class="nc" id="L188">                    Iterables.&lt;Action&lt;Rotation&gt;&gt;concat(</span>
<span class="nc" id="L189">                        swaps(r),</span>
<span class="nc" id="L190">                        substitutions(r),</span>
<span class="nc" id="L191">                        moves(r));</span>

<span class="nc" id="L193">                return Stream.concat(swaps(r).stream(), Stream.concat(substitutions(r).stream(), moves(r).stream()));</span>
            }

            private Set&lt;Move&gt; moves(Rotation rot) {
<span class="nc" id="L197">              Set&lt;Move&gt; moves = Sets.newHashSet();</span>

<span class="nc bnc" id="L199" title="All 2 branches missed.">              for (Player p : rot.getAll()) {</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">                for (Role r : Rotation.Role.values()) {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">                  for (int i = 0; i &lt; 5; i++) {</span>
<span class="nc" id="L202">                    moves.add(new Move(p, r, i));</span>
                  }
                }
<span class="nc" id="L205">              }</span>

<span class="nc" id="L207">              return moves;</span>
            }


            private Set&lt;Swap&gt; swaps(Rotation r) {
<span class="nc" id="L212">                Set&lt;Swap&gt; swaps = Sets.newHashSet();</span>

<span class="nc" id="L214">                ImmutableList&lt;Player&gt; ps = ImmutableList.copyOf(r.getAll());</span>

<span class="nc bnc" id="L216" title="All 2 branches missed.">                for (int lhs = 0; lhs &lt; ps.size(); lhs++) {</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">                    for (int rhs = lhs + 1; rhs &lt; ps.size(); rhs++) {</span>
<span class="nc" id="L218">                        swaps.add(new Swap(ps.get(lhs), ps.get(rhs)));</span>
                    }
                }

<span class="nc" id="L222">                return swaps;</span>
            }

            private Set&lt;Substitute&gt; substitutions(Rotation r) {
<span class="nc" id="L226">                Set&lt;Substitute&gt; ss = Sets.newHashSet();</span>

<span class="nc" id="L228">                List&lt;Player&gt; ps = Lists.newArrayList(r.getAll());</span>

<span class="nc" id="L230">                Iterables.removeAll(ps, ImmutableSet.copyOf(forced));</span>

<span class="nc bnc" id="L232" title="All 2 branches missed.">                for (Player in : available) {</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">                    if (!ps.contains(in)) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                        for (Player out : ps) {</span>
<span class="nc" id="L235">                            ss.add(new Substitute(in, out));</span>
<span class="nc" id="L236">                        }</span>
                    }
<span class="nc" id="L238">                }</span>

<span class="nc" id="L240">                return ss;</span>
            }


        };
    }

    public static RotationSelection regularSeason(
        TeamStats&lt;PitchingStats&gt; pitching, PitcherOverall method) {

<span class="nc" id="L250">        return new RotationSelection(</span>
<span class="nc" id="L251">            pitching, method, RotationDefinition.regularSeason(), Mode.REGULAR_SEASON.getPitchingSlots());</span>
    }

    public static RotationSelection expanded(
        TeamStats&lt;PitchingStats&gt; pitching, PitcherOverall method) {

<span class="nc" id="L257">        return new RotationSelection(</span>
<span class="nc" id="L258">            pitching, method, RotationDefinition.regularSeason(), Mode.EXPANDED.getPitchingSlots());</span>
    }

    public static RotationSelection playoffs(
        TeamStats&lt;PitchingStats&gt; pitching, PitcherOverall method) {

<span class="nc" id="L264">        return new RotationSelection(</span>
<span class="nc" id="L265">            pitching, method, RotationDefinition.playoffs(), Mode.PLAYOFFS.getPitchingSlots());</span>
    }

    public static RotationSelection forMode(
        Mode mode, TeamStats&lt;PitchingStats&gt; pitching, PitcherOverall method) {

<span class="nc bnc" id="L271" title="All 4 branches missed.">        switch (mode) {</span>
            case PRESEASON:
            case REGULAR_SEASON:
<span class="nc" id="L274">                return regularSeason(pitching, method);</span>
            case EXPANDED:
<span class="nc" id="L276">                return expanded(pitching, method);</span>
            case PLAYOFFS:
<span class="nc" id="L278">                return playoffs(pitching, method);</span>
            default:
<span class="nc" id="L280">                throw new IllegalStateException();</span>
        }
    }

    private static final class RotationDefinition {

        public Integer getRotationSize() {
<span class="nc" id="L287">            return rotation;</span>
        }

        public Integer getRelieversSize() {
<span class="nc" id="L291">            return relievers;</span>
        }

        public static RotationDefinition regularSeason() {
<span class="nc" id="L295">            return new RotationDefinition(REGULAR_SEASON_ROTATION, RELIEVERS);</span>
        }

        public static RotationDefinition playoffs() {
<span class="nc" id="L299">            return new RotationDefinition(PLAYOFFS_ROTATION, RELIEVERS);</span>
        }
<span class="nc" id="L301">        private static final Integer REGULAR_SEASON_ROTATION = Integer</span>
<span class="nc" id="L302">            .valueOf(5);</span>

<span class="nc" id="L304">        private static final Integer PLAYOFFS_ROTATION = Integer.valueOf(4);</span>

<span class="nc" id="L306">        private static final Integer RELIEVERS = Integer.valueOf(4);</span>

        private final Integer rotation;

        private final Integer relievers;

<span class="nc" id="L312">        private RotationDefinition(Integer rotation, Integer relievers) {</span>
<span class="nc" id="L313">            this.rotation = rotation;</span>
<span class="nc" id="L314">            this.relievers = relievers;</span>
<span class="nc" id="L315">        }</span>
    }

    private static class Swap implements Action&lt;Rotation&gt; {

        private Player lhs;
        private Player rhs;

<span class="nc" id="L323">        public Swap(Player lhs, Player rhs) {</span>
<span class="nc" id="L324">            this.lhs = lhs;</span>
<span class="nc" id="L325">            this.rhs = rhs;</span>
<span class="nc" id="L326">        }</span>

        public Rotation apply(Rotation r) {
<span class="nc" id="L329">            return r.swap(lhs, rhs);</span>
        }
    }

    private static class Substitute implements Action&lt;Rotation&gt; {

        private Player in;
        private Player out;

<span class="nc" id="L338">        public Substitute(Player in, Player out) {</span>
<span class="nc" id="L339">            this.in = in;</span>
<span class="nc" id="L340">            this.out = out;</span>
<span class="nc" id="L341">        }</span>

        public Rotation apply(Rotation r) {
<span class="nc" id="L344">            return r.substitute(in, out);</span>
        }
    }

    private static class Move implements Action&lt;Rotation&gt; {
      private Player p;
      private Rotation.Role role;
      private Integer idx;

<span class="nc" id="L353">      public Move(Player p, Rotation.Role role, Integer idx) {</span>
<span class="nc" id="L354">        this.p = p;</span>
<span class="nc" id="L355">        this.role = role;</span>
<span class="nc" id="L356">        this.idx = idx;</span>
<span class="nc" id="L357">      }</span>

      public Rotation apply(Rotation r) {
<span class="nc" id="L360">        return r.move(p, role, idx);</span>
      }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>