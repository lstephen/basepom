<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DepthChartSelection.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ootp-ai</a> &gt; <a href="index.source.html" class="el_package">com.github.lstephen.ootp.ai.selection.depthchart</a> &gt; <span class="el_source">DepthChartSelection.java</span></div><h1>DepthChartSelection.java</h1><pre class="source lang-java linenums">package com.github.lstephen.ootp.ai.selection.depthchart;

import com.github.lstephen.ootp.ai.player.Player;
import com.github.lstephen.ootp.ai.player.Slot;
import com.github.lstephen.ootp.ai.player.ratings.Position;
import com.github.lstephen.ootp.ai.selection.lineup.All;
import com.github.lstephen.ootp.ai.selection.lineup.AllLineups;
import com.github.lstephen.ootp.ai.selection.lineup.Defense;
import com.github.lstephen.ootp.ai.selection.lineup.Lineup;
import com.github.lstephen.ootp.ai.stats.BattingStats;
import com.github.lstephen.ootp.ai.stats.TeamStats;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;

import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Ordering;
import com.google.common.collect.Sets;

/**
 *
 * @author lstephen
 */
public final class DepthChartSelection {

    private final TeamStats&lt;BattingStats&gt; predictions;

<span class="nc" id="L34">    private DepthChartSelection(TeamStats&lt;BattingStats&gt; predictions) {</span>
<span class="nc" id="L35">        this.predictions = predictions;</span>
<span class="nc" id="L36">    }</span>

    public AllDepthCharts select(
        AllLineups lineups, Iterable&lt;Player&gt; available) {

<span class="nc" id="L41">        return AllDepthCharts.create(All</span>
<span class="nc" id="L42">            .&lt;DepthChart&gt;builder()</span>
<span class="nc" id="L43">            .vsRhp(select(lineups.getVsRhp(), available, Lineup.VsHand.VS_RHP))</span>
<span class="nc" id="L44">            .vsRhpPlusDh(select(lineups.getVsRhpPlusDh(), available, Lineup.VsHand.VS_RHP))</span>
<span class="nc" id="L45">            .vsLhp(select(lineups.getVsLhp(), available, Lineup.VsHand.VS_LHP))</span>
<span class="nc" id="L46">            .vsLhpPlusDh(select(lineups.getVsLhpPlusDh(), available, Lineup.VsHand.VS_LHP))</span>
<span class="nc" id="L47">            .build());</span>
    }

    private DepthChart select(Lineup lineup, Iterable&lt;Player&gt; available, Lineup.VsHand vs) {
<span class="nc" id="L51">        DepthChart dc = new DepthChart();</span>

<span class="nc" id="L53">        Iterable&lt;Player&gt; bench = Sets.difference(ImmutableSet.copyOf(available), lineup.playerSet());</span>

<span class="nc bnc" id="L55" title="All 2 branches missed.">        for (Lineup.Entry entry : lineup) {</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">            if (entry.getPositionEnum() == Position.PITCHER) {</span>
<span class="nc" id="L57">                continue;</span>
            }

<span class="nc" id="L60">            dc.setStarter(entry.getPositionEnum(), entry.getPlayer());</span>

<span class="nc bnc" id="L62" title="All 2 branches missed.">            if (entry.getPositionEnum() != Position.DESIGNATED_HITTER) {</span>
<span class="nc" id="L63">                Optional&lt;Player&gt; dr = selectDefensiveReplacement(entry.getPositionEnum(), entry.getPlayer(), bench);</span>

<span class="nc bnc" id="L65" title="All 2 branches missed.">                if (dr.isPresent()) {</span>
<span class="nc" id="L66">                    dc.setDefensiveReplacement(entry.getPositionEnum(), dr.get());</span>
                }
            }

<span class="nc" id="L70">            selectBackup(dc, entry.getPositionEnum(), bench, vs);</span>
<span class="nc" id="L71">        }</span>

<span class="nc" id="L73">        return dc;</span>
    }

    private Optional&lt;Player&gt; selectDefensiveReplacement(final Position position, Player starter, Iterable&lt;Player&gt; bench) {

        Player candidate = Ordering
<span class="nc" id="L79">            .natural()</span>
<span class="nc" id="L80">            .onResultOf(new Function&lt;Player, Double&gt;() {</span>
                public Double apply(Player p) {
<span class="nc" id="L82">                    return p.getDefensiveRatings().getPositionScore(position);</span>
                }
            })
<span class="nc" id="L85">            .compound(Player.byTieBreak())</span>
<span class="nc" id="L86">            .max(bench);</span>

<span class="nc" id="L88">        return candidate.getDefensiveRatings().getPositionScore(position)</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">            &gt; starter.getDefensiveRatings().getPositionScore(position) * 1.1</span>
<span class="nc" id="L90">            ? Optional.of(candidate)</span>
<span class="nc" id="L91">            : Optional.&lt;Player&gt;absent();</span>
    }

    private void selectBackup(DepthChart dc, Position position, Iterable&lt;Player&gt; bench, Lineup.VsHand vs) {

<span class="nc" id="L96">        Player starter = dc.getStarter(position);</span>
<span class="nc" id="L97">        Set&lt;Player&gt; backups = ImmutableSet.copyOf(Iterables.limit(selectBackups(position, bench, vs), 2));</span>

<span class="nc" id="L99">        Player primary = starter;</span>

<span class="nc" id="L101">        Long remaining = 100L;</span>

<span class="nc bnc" id="L103" title="All 2 branches missed.">        for (Player backup : backups) {</span>
<span class="nc" id="L104">            Double pct = calculateBackupPct(position, primary, backup, vs);</span>

<span class="nc" id="L106">            Long primaryPct = remaining - Math.round(pct * remaining);</span>

<span class="nc bnc" id="L108" title="All 4 branches missed.">            if (backups.contains(primary) &amp;&amp; primaryPct &gt;= 1) {</span>
<span class="nc" id="L109">                dc.addBackup(position, primary, primaryPct);</span>

            }

<span class="nc" id="L113">            remaining -= primaryPct;</span>
<span class="nc" id="L114">            primary = backup;</span>
<span class="nc" id="L115">        }</span>

<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (remaining &gt;= 1) {</span>
<span class="nc" id="L118">            dc.addBackup(position, primary, remaining);</span>
        }
<span class="nc" id="L120">    }</span>

    private Double calculateBackupPct(Position p, Player primary, Player backup, Lineup.VsHand vs) {
<span class="nc" id="L123">        Double factor =</span>
<span class="nc bnc" id="L124" title="All 4 branches missed.">            primary.canPlay(p) &amp;&amp; !backup.canPlay(p) ? 0.5 : 1.0;</span>

<span class="nc" id="L126">        Double primaryAbility = vs.getStats(predictions, primary).getWobaPlus()</span>
<span class="nc" id="L127">            + Defense.getPositionFactor(p) * primary.getDefensiveRatings().getPositionScore(p) / 2;</span>
<span class="nc" id="L128">        Double backupAbility = vs.getStats(predictions, backup).getWobaPlus()</span>
<span class="nc" id="L129">            + Defense.getPositionFactor(p) * backup.getDefensiveRatings().getPositionScore(p) / 2;</span>

<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (backupAbility &gt; primaryAbility) {</span>
<span class="nc" id="L132">            backupAbility = primaryAbility;</span>
        }

<span class="nc" id="L135">        Double daysOff = (double) (primaryAbility - backupAbility) / Defense.getPositionFactor(p) + 1;</span>

<span class="nc" id="L137">        return factor * 1 / (daysOff + 1);</span>
    }

    private Iterable&lt;Player&gt; selectBackups(final Position position, Iterable&lt;Player&gt; bench, final Lineup.VsHand vs) {

        ImmutableList&lt;Player&gt; sortedBench = Ordering
<span class="nc" id="L143">            .natural()</span>
<span class="nc" id="L144">            .reverse()</span>
<span class="nc" id="L145">            .onResultOf(new Function&lt;Player, Double&gt;() {</span>
                public Double apply(Player player) {
<span class="nc" id="L147">                    return vs.getStats(predictions, player).getWobaPlus()</span>
<span class="nc" id="L148">                        + Defense.getPositionFactor(position) * player.getDefensiveRatings().getPositionScore(position) / 2;</span>
                }
            })
<span class="nc" id="L151">            .compound(Player.byTieBreak())</span>
<span class="nc" id="L152">            .immutableSortedCopy(bench);</span>

<span class="nc" id="L154">        Player fallback = sortedBench.get(0);</span>

<span class="nc" id="L156">        List&lt;Player&gt; backups = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L158" title="All 4 branches missed.">        if (position != Position.DESIGNATED_HITTER &amp;&amp; position != Position.FIRST_BASE) {</span>
<span class="nc" id="L159">            Iterables.addAll(backups, selectBackupByPosition(position, sortedBench));</span>
        }

<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (backups.isEmpty()) {</span>
<span class="nc" id="L163">            Iterables.addAll(backups, selectBackupBySlot(position, sortedBench));</span>
        }

<span class="nc bnc" id="L166" title="All 2 branches missed.">        if (backups.isEmpty()) {</span>
<span class="nc" id="L167">            backups.add(fallback);</span>
        }

<span class="nc" id="L170">        return backups;</span>
    }

    private Iterable&lt;Player&gt; selectBackupByPosition(Position position, Iterable&lt;Player&gt; bench) {
<span class="nc" id="L174">        List&lt;Player&gt; result = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L176" title="All 2 branches missed.">        for (Player p : bench) {</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">            if (p.getDefensiveRatings().getPositionScore(position) &gt; 0) {</span>
<span class="nc" id="L178">                result.add(p);</span>
            }
<span class="nc" id="L180">        }</span>

<span class="nc" id="L182">        return result;</span>
    }

    private Iterable&lt;Player&gt; selectBackupBySlot(Position position, Iterable&lt;Player&gt; bench) {
<span class="nc bnc" id="L186" title="All 4 branches missed.">        switch (position) {</span>
            case SECOND_BASE:
            case THIRD_BASE:
            case SHORTSTOP:
<span class="nc" id="L190">                return selectBackupBySlot(Slot.IF, bench);</span>
            case LEFT_FIELD:
            case CENTER_FIELD:
            case RIGHT_FIELD:
<span class="nc" id="L194">                return selectBackupBySlot(Slot.OF, bench);</span>
            case FIRST_BASE:
            case DESIGNATED_HITTER:
<span class="nc" id="L197">                return selectBackupBySlot(Slot.H, bench);</span>
            default:
<span class="nc" id="L199">                return Collections.emptySet();</span>
        }
    }

    private Iterable&lt;Player&gt; selectBackupBySlot(Slot slot, Iterable&lt;Player&gt; bench) {
<span class="nc" id="L204">        List&lt;Player&gt; result = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L206" title="All 2 branches missed.">        for (Player p : bench) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">            if (p.getSlots().contains(slot)) {</span>
<span class="nc" id="L208">                result.add(p);</span>
            }
<span class="nc" id="L210">        }</span>

<span class="nc" id="L212">        return result;</span>
    }

    public static DepthChartSelection create(TeamStats&lt;BattingStats&gt; predictions) {
<span class="nc" id="L216">        return new DepthChartSelection(predictions);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>