<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Bench.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ootp-ai</a> &gt; <a href="index.source.html" class="el_package">com.ljs.ootp.ai.selection.bench</a> &gt; <span class="el_source">Bench.java</span></div><h1>Bench.java</h1><pre class="source lang-java linenums">package com.ljs.ootp.ai.selection.bench;

import com.ljs.ootp.ai.io.Printable;
import com.ljs.ootp.ai.io.Printables;
import com.ljs.ootp.ai.player.Player;
import com.ljs.ootp.ai.selection.lineup.AllLineups;
import com.ljs.ootp.ai.selection.lineup.Lineup;
import com.ljs.ootp.ai.stats.BattingStats;
import com.ljs.ootp.ai.stats.SplitPercentages;
import com.ljs.ootp.ai.stats.TeamStats;

import java.io.PrintWriter;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import com.ljs.ai.search.hillclimbing.HillClimbing;
import com.ljs.ai.search.hillclimbing.RepeatedHillClimbing;
import com.ljs.ai.search.hillclimbing.Validator;
import com.ljs.ai.search.hillclimbing.action.Action;
import com.ljs.ai.search.hillclimbing.action.ActionGenerator;
import com.ljs.ai.search.hillclimbing.action.SequencedAction;

import com.google.common.base.Function;
import com.google.common.base.Predicates;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Maps;
import com.google.common.collect.Ordering;
import com.google.common.collect.Sets;

/**
 *
 * @author lstephen
 */
public class Bench implements Printable {

    private final AllLineups lineups;

    private final ImmutableSet&lt;Player&gt; selected;

    private final ImmutableSet&lt;Player&gt; players;

    private final Integer maxSize;

    private final TeamStats&lt;BattingStats&gt; predictions;

    private static SplitPercentages pcts;

<span class="nc" id="L59">    private Bench(AllLineups lineups, Iterable&lt;Player&gt; selected, Iterable&lt;Player&gt; players, Integer maxSize, TeamStats&lt;BattingStats&gt; predictions) {</span>
<span class="nc" id="L60">        this.lineups = lineups;</span>
<span class="nc" id="L61">        this.players = ImmutableSet.copyOf(players);</span>
<span class="nc" id="L62">        this.selected = ImmutableSet.copyOf(selected);</span>
<span class="nc" id="L63">        this.maxSize = maxSize;</span>
<span class="nc" id="L64">        this.predictions = predictions;</span>
<span class="nc" id="L65">    }</span>

    public static void setPercentages(SplitPercentages pcts) {
<span class="nc" id="L68">        Bench.pcts = pcts;</span>
<span class="nc" id="L69">    }</span>

    private Bench with(Player p) {
<span class="nc" id="L72">        return new Bench(</span>
            lineups,
            selected,
<span class="nc" id="L75">            Iterables.concat(players, ImmutableSet.of(p)),</span>
            maxSize,
            predictions);
    }

    private Bench without(Player p) {
<span class="nc" id="L81">        return new Bench(</span>
            lineups,
            selected,
<span class="nc" id="L84">            Iterables.filter(players, Predicates.not(Predicates.equalTo(p))),</span>
            maxSize,
            predictions);
    }

    public ImmutableSet&lt;Player&gt; players() {
<span class="nc" id="L90">        return players;</span>
    }

    private Double score() {
<span class="nc" id="L94">        Double score = 0.0;</span>

<span class="nc" id="L96">        score += (pcts.getVsLhpPercentage() * score(lineups.getVsLhp(), Lineup.VsHand.VS_LHP));</span>
<span class="nc" id="L97">        score += (pcts.getVsLhpPercentage() * score(lineups.getVsLhpPlusDh(), Lineup.VsHand.VS_LHP));</span>
<span class="nc" id="L98">        score += (pcts.getVsRhpPercentage() * score(lineups.getVsRhp(), Lineup.VsHand.VS_RHP));</span>
<span class="nc" id="L99">        score += (pcts.getVsRhpPercentage() * score(lineups.getVsRhpPlusDh(), Lineup.VsHand.VS_RHP));</span>

<span class="nc" id="L101">        return score;</span>
    }

    private Double score(Player p) {
<span class="nc" id="L105">        Double score = 0.0;</span>

<span class="nc" id="L107">        score += (pcts.getVsLhpPercentage() * score(p, lineups.getVsLhp(), Lineup.VsHand.VS_LHP));</span>
<span class="nc" id="L108">        score += (pcts.getVsLhpPercentage() * score(p, lineups.getVsLhpPlusDh(), Lineup.VsHand.VS_LHP));</span>
<span class="nc" id="L109">        score += (pcts.getVsRhpPercentage() * score(p, lineups.getVsRhp(), Lineup.VsHand.VS_RHP));</span>
<span class="nc" id="L110">        score += (pcts.getVsRhpPercentage() * score(p, lineups.getVsRhpPlusDh(), Lineup.VsHand.VS_RHP));</span>

<span class="nc" id="L112">        return score;</span>
    }

    private Double score(Lineup lineup, Lineup.VsHand vs) {
<span class="nc" id="L116">        return new BenchScorer(predictions)</span>
<span class="nc" id="L117">            .score(</span>
<span class="nc" id="L118">                Iterables.concat(</span>
<span class="nc" id="L119">                    Sets.difference(selected, lineup.playerSet()), players),</span>
                    lineup,
                    vs);
    }

    private Double score(Player p, Lineup lineup, Lineup.VsHand vs) {
<span class="nc" id="L125">        return new BenchScorer(predictions)</span>
<span class="nc" id="L126">            .score(</span>
                p,
<span class="nc" id="L128">                Iterables.concat(</span>
<span class="nc" id="L129">                    Sets.difference(selected, lineup.playerSet()), players),</span>
                    lineup,
                    vs);
    }

    private Integer totalAge() {
<span class="nc" id="L135">        Integer age = 0;</span>

<span class="nc bnc" id="L137" title="All 2 branches missed.">        for (Player p : players) {</span>
<span class="nc" id="L138">            age += p.getAge();</span>
<span class="nc" id="L139">        }</span>

<span class="nc" id="L141">        return age;</span>
    }

    public void print(PrintWriter w) {
<span class="nc" id="L145">        final Map&lt;Player, Double&gt; scores = Maps.newHashMap();</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">       for (Player p : players()) {</span>
<span class="nc" id="L147">           scores.put(p, score(p));</span>
<span class="nc" id="L148">       }</span>

<span class="nc" id="L150">       w.print(&quot;Bench:&quot;);</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">       for (Player p : Ordering</span>
<span class="nc" id="L152">           .natural()</span>
<span class="nc" id="L153">           .reverse()</span>
<span class="nc" id="L154">           .onResultOf(new Function&lt;Player, Double&gt;() {</span>
               public Double apply(Player p) {
<span class="nc" id="L156">                   return scores.get(p);</span>
               }
           })
<span class="nc" id="L159">           .sortedCopy(scores.keySet())) {</span>

<span class="nc" id="L161">           w.print(p.getShortName() + &quot;-&quot; + Math.round(scores.get(p)) + &quot;/&quot;);</span>
<span class="nc" id="L162">       }</span>
<span class="nc" id="L163">       w.println();</span>
<span class="nc" id="L164">    }</span>

    private static Validator&lt;Bench&gt; validator() {
<span class="nc bnc" id="L167" title="All 2 branches missed.">        Predicate&lt;Bench&gt; size = (b) -&gt;  b.selected.size() + b.players.size() &lt;= b.maxSize;</span>

<span class="nc" id="L169">        Predicate&lt;Bench&gt; anyInLineup = (b) -&gt;</span>
<span class="nc" id="L170">          b.players</span>
<span class="nc" id="L171">            .stream()</span>
<span class="nc" id="L172">            .filter((p) -&gt; b.lineups.getAllPlayers().contains(p))</span>
<span class="nc" id="L173">            .findAny()</span>
<span class="nc" id="L174">            .isPresent();</span>

<span class="nc" id="L176">        return size.and(anyInLineup.negate())::test;</span>
    }

    private static Ordering&lt;Bench&gt; byScore() {
<span class="nc" id="L180">        return Ordering.natural().onResultOf(Bench::score);</span>
    }

    private static Ordering&lt;Bench&gt; bySize() {
<span class="nc" id="L184">        return Ordering.natural().onResultOf((b) -&gt; b.players.size());</span>
    }

    private static Ordering&lt;Bench&gt; byAge() {
<span class="nc" id="L188">        return Ordering.natural().reverse().onResultOf(Bench::totalAge);</span>
    }

    private static Ordering&lt;Bench&gt; heuristic() {
<span class="nc" id="L192">        return byScore()</span>
<span class="nc" id="L193">            .compound(bySize().reverse())</span>
<span class="nc" id="L194">            .compound(byAge());</span>
    }

    private static ActionGenerator&lt;Bench&gt; actionGenerator(final Iterable&lt;Player&gt; available) {
<span class="nc" id="L198">        Function&lt;Bench, Set&lt;Add&gt;&gt; adds = (b) -&gt;</span>
<span class="nc" id="L199">          StreamSupport.stream(available.spliterator(), false)</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            .filter((p) -&gt; !b.lineups.getAllPlayers().contains(p))</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">            .filter((p) -&gt; !b.players.contains(p))</span>
<span class="nc" id="L202">            .map(Add::new)</span>
<span class="nc" id="L203">            .collect(Collectors.toSet());</span>

<span class="nc" id="L205">        Function&lt;Bench, Set&lt;Remove&gt;&gt; removes = (b) -&gt;</span>
<span class="nc" id="L206">          b.players.stream().map(Remove::new).collect(Collectors.toSet());</span>

<span class="nc" id="L208">        return (b) -&gt; {</span>
<span class="nc" id="L209">          Set&lt;Add&gt; as = adds.apply(b);</span>
<span class="nc" id="L210">          Set&lt;Remove&gt; rs = removes.apply(b);</span>

<span class="nc" id="L212">          Set&lt;Action&lt;Bench&gt;&gt; actions = new HashSet&lt;&gt;();</span>

<span class="nc" id="L214">          actions.addAll(as);</span>
<span class="nc" id="L215">          actions.addAll(rs);</span>
<span class="nc" id="L216">          actions.addAll(SequencedAction.merged(as, rs));</span>

<span class="nc" id="L218">          return actions;</span>
        };
    }

    private static Callable&lt;Bench&gt; initialStateGenerator(final AllLineups lineups, final Iterable&lt;Player&gt; selected, final TeamStats&lt;BattingStats&gt; predictions, final Iterable&lt;Player&gt; available, final Integer maxSize) {
<span class="nc" id="L223">        return new Callable&lt;Bench&gt;() {</span>
            public Bench call() {
<span class="nc" id="L225">                List&lt;Player&gt; candidates = new ArrayList&lt;&gt;(</span>
<span class="nc" id="L226">                    Sets.difference(</span>
<span class="nc" id="L227">                        ImmutableSet.copyOf(available),</span>
<span class="nc" id="L228">                        lineups.getAllPlayers()));</span>

<span class="nc" id="L230">                Collections.shuffle(candidates);</span>

<span class="nc" id="L232">                return new Bench(lineups, selected, Iterables.limit(candidates, maxSize - Iterables.size(selected)), maxSize, predictions);</span>
            }
        };
    }

    public static Bench select(AllLineups lineups, Iterable&lt;Player&gt; selected, TeamStats&lt;BattingStats&gt; predictions, Iterable&lt;Player&gt; available, Integer maxSize) {
        HillClimbing.Builder&lt;Bench&gt; builder = HillClimbing
<span class="nc" id="L239">            .&lt;Bench&gt;builder()</span>
<span class="nc" id="L240">            .heuristic(heuristic())</span>
<span class="nc" id="L241">            .validator(validator())</span>
<span class="nc" id="L242">            .actionGenerator(actionGenerator(available));</span>

<span class="nc" id="L244">       Bench result = new RepeatedHillClimbing&lt;Bench&gt;(initialStateGenerator(lineups, selected, predictions, available, maxSize), builder).search();</span>

<span class="nc" id="L246">       Printables.print(result).to(System.out);</span>

<span class="nc" id="L248">       return result;</span>
    }

    private static class Add implements Action&lt;Bench&gt; {

        private final Player add;

<span class="nc" id="L255">        public Add(Player add) {</span>
<span class="nc" id="L256">            this.add = add;</span>
<span class="nc" id="L257">        }</span>

        public Bench apply(Bench b) {
<span class="nc" id="L260">            return b.with(add);</span>
        }

    }

    private static class Remove implements Action&lt;Bench&gt; {

        private final Player remove;

<span class="nc" id="L269">        public Remove(Player remove) {</span>
<span class="nc" id="L270">            this.remove = remove;</span>
<span class="nc" id="L271">        }</span>

        public Bench apply(Bench b) {
<span class="nc" id="L274">            return b.without(remove);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>