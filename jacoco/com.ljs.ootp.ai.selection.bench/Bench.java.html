<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Bench.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ootp-ai</a> &gt; <a href="index.source.html" class="el_package">com.ljs.ootp.ai.selection.bench</a> &gt; <span class="el_source">Bench.java</span></div><h1>Bench.java</h1><pre class="source lang-java linenums">package com.ljs.ootp.ai.selection.bench;

import com.ljs.ootp.ai.io.Printable;
import com.ljs.ootp.ai.io.Printables;
import com.ljs.ootp.ai.player.Player;
import com.ljs.ootp.ai.selection.lineup.AllLineups;
import com.ljs.ootp.ai.selection.lineup.Lineup;
import com.ljs.ootp.ai.stats.BattingStats;
import com.ljs.ootp.ai.stats.SplitPercentages;
import com.ljs.ootp.ai.stats.TeamStats;

import java.io.PrintWriter;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import com.github.lstephen.ai.search.HillClimbing;
import com.github.lstephen.ai.search.RepeatedHillClimbing;
import com.github.lstephen.ai.search.Validator;
import com.github.lstephen.ai.search.action.Action;
import com.github.lstephen.ai.search.action.ActionGenerator;
import com.github.lstephen.ai.search.action.SequencedAction;

import com.google.common.base.Function;
import com.google.common.base.Predicates;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Maps;
import com.google.common.collect.Ordering;
import com.google.common.collect.Sets;

/**
 *
 * @author lstephen
 */
public class Bench implements Printable {

    private final AllLineups lineups;

    private final ImmutableSet&lt;Player&gt; selected;

    private final ImmutableSet&lt;Player&gt; players;

    private final Integer maxSize;

    private final TeamStats&lt;BattingStats&gt; predictions;

    private static SplitPercentages pcts;

<span class="nc" id="L61">    private Bench(AllLineups lineups, Iterable&lt;Player&gt; selected, Iterable&lt;Player&gt; players, Integer maxSize, TeamStats&lt;BattingStats&gt; predictions) {</span>
<span class="nc" id="L62">        this.lineups = lineups;</span>
<span class="nc" id="L63">        this.players = ImmutableSet.copyOf(players);</span>
<span class="nc" id="L64">        this.selected = ImmutableSet.copyOf(selected);</span>
<span class="nc" id="L65">        this.maxSize = maxSize;</span>
<span class="nc" id="L66">        this.predictions = predictions;</span>
<span class="nc" id="L67">    }</span>

    public static void setPercentages(SplitPercentages pcts) {
<span class="nc" id="L70">        Bench.pcts = pcts;</span>
<span class="nc" id="L71">    }</span>

    private Bench with(Player p) {
<span class="nc" id="L74">        return new Bench(</span>
            lineups,
            selected,
<span class="nc" id="L77">            Iterables.concat(players, ImmutableSet.of(p)),</span>
            maxSize,
            predictions);
    }

    private Bench without(Player p) {
<span class="nc" id="L83">        return new Bench(</span>
            lineups,
            selected,
<span class="nc" id="L86">            Iterables.filter(players, Predicates.not(Predicates.equalTo(p))),</span>
            maxSize,
            predictions);
    }

    public ImmutableSet&lt;Player&gt; players() {
<span class="nc" id="L92">        return players;</span>
    }

    private Double score() {
<span class="nc" id="L96">        Double score = 0.0;</span>

<span class="nc" id="L98">        score += (pcts.getVsLhpPercentage() * score(lineups.getVsLhp(), Lineup.VsHand.VS_LHP));</span>
<span class="nc" id="L99">        score += (pcts.getVsLhpPercentage() * score(lineups.getVsLhpPlusDh(), Lineup.VsHand.VS_LHP));</span>
<span class="nc" id="L100">        score += (pcts.getVsRhpPercentage() * score(lineups.getVsRhp(), Lineup.VsHand.VS_RHP));</span>
<span class="nc" id="L101">        score += (pcts.getVsRhpPercentage() * score(lineups.getVsRhpPlusDh(), Lineup.VsHand.VS_RHP));</span>

<span class="nc" id="L103">        return score;</span>
    }

    private Double score(Player p) {
<span class="nc" id="L107">        Double score = 0.0;</span>

<span class="nc" id="L109">        score += (pcts.getVsLhpPercentage() * score(p, lineups.getVsLhp(), Lineup.VsHand.VS_LHP));</span>
<span class="nc" id="L110">        score += (pcts.getVsLhpPercentage() * score(p, lineups.getVsLhpPlusDh(), Lineup.VsHand.VS_LHP));</span>
<span class="nc" id="L111">        score += (pcts.getVsRhpPercentage() * score(p, lineups.getVsRhp(), Lineup.VsHand.VS_RHP));</span>
<span class="nc" id="L112">        score += (pcts.getVsRhpPercentage() * score(p, lineups.getVsRhpPlusDh(), Lineup.VsHand.VS_RHP));</span>

<span class="nc" id="L114">        return score;</span>
    }

    private Double score(Lineup lineup, Lineup.VsHand vs) {
<span class="nc" id="L118">        return new BenchScorer(predictions)</span>
<span class="nc" id="L119">            .score(</span>
<span class="nc" id="L120">                Iterables.concat(</span>
<span class="nc" id="L121">                    Sets.difference(selected, lineup.playerSet()), players),</span>
                    lineup,
                    vs);
    }

    private Double score(Player p, Lineup lineup, Lineup.VsHand vs) {
<span class="nc" id="L127">        return new BenchScorer(predictions)</span>
<span class="nc" id="L128">            .score(</span>
                p,
<span class="nc" id="L130">                Iterables.concat(</span>
<span class="nc" id="L131">                    Sets.difference(selected, lineup.playerSet()), players),</span>
                    lineup,
                    vs);
    }

    private Integer totalAge() {
<span class="nc" id="L137">        Integer age = 0;</span>

<span class="nc bnc" id="L139" title="All 2 branches missed.">        for (Player p : players) {</span>
<span class="nc" id="L140">            age += p.getAge();</span>
<span class="nc" id="L141">        }</span>

<span class="nc" id="L143">        return age;</span>
    }

    public void print(PrintWriter w) {
<span class="nc" id="L147">        final Map&lt;Player, Double&gt; scores = Maps.newHashMap();</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">       for (Player p : players()) {</span>
<span class="nc" id="L149">           scores.put(p, score(p));</span>
<span class="nc" id="L150">       }</span>

<span class="nc" id="L152">       w.print(&quot;Bench:&quot;);</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">       for (Player p : Ordering</span>
<span class="nc" id="L154">           .natural()</span>
<span class="nc" id="L155">           .reverse()</span>
<span class="nc" id="L156">           .onResultOf(new Function&lt;Player, Double&gt;() {</span>
               public Double apply(Player p) {
<span class="nc" id="L158">                   return scores.get(p);</span>
               }
           })
<span class="nc" id="L161">           .sortedCopy(scores.keySet())) {</span>

<span class="nc" id="L163">           w.print(p.getShortName() + &quot;-&quot; + Math.round(scores.get(p)) + &quot;/&quot;);</span>
<span class="nc" id="L164">       }</span>
<span class="nc" id="L165">       w.println();</span>
<span class="nc" id="L166">    }</span>

    private static Validator&lt;Bench&gt; validator() {
<span class="nc bnc" id="L169" title="All 2 branches missed.">        Predicate&lt;Bench&gt; size = (b) -&gt;  b.selected.size() + b.players.size() &lt;= b.maxSize;</span>

<span class="nc" id="L171">        Predicate&lt;Bench&gt; anyInLineup = (b) -&gt;</span>
<span class="nc" id="L172">          b.players</span>
<span class="nc" id="L173">            .stream()</span>
<span class="nc" id="L174">            .filter((p) -&gt; b.lineups.getAllPlayers().contains(p))</span>
<span class="nc" id="L175">            .findAny()</span>
<span class="nc" id="L176">            .isPresent();</span>

<span class="nc" id="L178">        return size.and(anyInLineup.negate())::test;</span>
    }

    private static Ordering&lt;Bench&gt; byScore() {
<span class="nc" id="L182">        return Ordering.natural().onResultOf(Bench::score);</span>
    }

    private static Ordering&lt;Bench&gt; bySize() {
<span class="nc" id="L186">        return Ordering.natural().onResultOf((b) -&gt; b.players.size());</span>
    }

    private static Ordering&lt;Bench&gt; byAge() {
<span class="nc" id="L190">        return Ordering.natural().reverse().onResultOf(Bench::totalAge);</span>
    }

    private static Ordering&lt;Bench&gt; heuristic() {
<span class="nc" id="L194">        return byScore()</span>
<span class="nc" id="L195">            .compound(bySize().reverse())</span>
<span class="nc" id="L196">            .compound(byAge());</span>
    }

    private static ActionGenerator&lt;Bench&gt; actionGenerator(final Iterable&lt;Player&gt; available) {
<span class="nc" id="L200">        Function&lt;Bench, Set&lt;Add&gt;&gt; adds = (b) -&gt;</span>
<span class="nc" id="L201">          StreamSupport.stream(available.spliterator(), false)</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">            .filter((p) -&gt; !b.lineups.getAllPlayers().contains(p))</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            .filter((p) -&gt; !b.players.contains(p))</span>
<span class="nc" id="L204">            .map(Add::new)</span>
<span class="nc" id="L205">            .collect(Collectors.toSet());</span>

<span class="nc" id="L207">        Function&lt;Bench, Set&lt;Remove&gt;&gt; removes = (b) -&gt;</span>
<span class="nc" id="L208">          b.players.stream().map(Remove::new).collect(Collectors.toSet());</span>

<span class="nc" id="L210">        return (b) -&gt; {</span>
<span class="nc" id="L211">          Set&lt;Add&gt; as = adds.apply(b);</span>
<span class="nc" id="L212">          Set&lt;Remove&gt; rs = removes.apply(b);</span>

<span class="nc" id="L214">          return Stream.concat(Stream.concat(as.stream(), rs.stream()), SequencedAction.merged(as, rs));</span>
        };
    }

    private static Supplier&lt;Bench&gt; initialStateGenerator(final AllLineups lineups, final Iterable&lt;Player&gt; selected, final TeamStats&lt;BattingStats&gt; predictions, final Iterable&lt;Player&gt; available, final Integer maxSize) {
<span class="nc" id="L219">        return new Supplier&lt;Bench&gt;() {</span>
            public Bench get() {
<span class="nc" id="L221">                List&lt;Player&gt; candidates = new ArrayList&lt;&gt;(</span>
<span class="nc" id="L222">                    Sets.difference(</span>
<span class="nc" id="L223">                        ImmutableSet.copyOf(available),</span>
<span class="nc" id="L224">                        lineups.getAllPlayers()));</span>

<span class="nc" id="L226">                Collections.shuffle(candidates);</span>

<span class="nc" id="L228">                return new Bench(lineups, selected, Iterables.limit(candidates, maxSize - Iterables.size(selected)), maxSize, predictions);</span>
            }
        };
    }

    public static Bench select(AllLineups lineups, Iterable&lt;Player&gt; selected, TeamStats&lt;BattingStats&gt; predictions, Iterable&lt;Player&gt; available, Integer maxSize) {
        HillClimbing&lt;Bench&gt; hc = HillClimbing
<span class="nc" id="L235">            .&lt;Bench&gt;builder()</span>
<span class="nc" id="L236">            .heuristic(heuristic())</span>
<span class="nc" id="L237">            .validator(validator())</span>
<span class="nc" id="L238">            .actionGenerator(actionGenerator(available))</span>
<span class="nc" id="L239">            .build();</span>

<span class="nc" id="L241">       Bench result = new RepeatedHillClimbing&lt;Bench&gt;(initialStateGenerator(lineups, selected, predictions, available, maxSize), hc).search();</span>

<span class="nc" id="L243">       Printables.print(result).to(System.out);</span>

<span class="nc" id="L245">       return result;</span>
    }

    private static class Add implements Action&lt;Bench&gt; {

        private final Player add;

<span class="nc" id="L252">        public Add(Player add) {</span>
<span class="nc" id="L253">            this.add = add;</span>
<span class="nc" id="L254">        }</span>

        public Bench apply(Bench b) {
<span class="nc" id="L257">            return b.with(add);</span>
        }

    }

    private static class Remove implements Action&lt;Bench&gt; {

        private final Player remove;

<span class="nc" id="L266">        public Remove(Player remove) {</span>
<span class="nc" id="L267">            this.remove = remove;</span>
<span class="nc" id="L268">        }</span>

        public Bench apply(Bench b) {
<span class="nc" id="L271">            return b.without(remove);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>